import { dbGet, dbGetAll, dbGetByIndex } from './db.js';
import { escapeHtml } from './utils.js';

export async function exportKnowledge(target, options = {}) {
  const topics = options.topicIds
    ? await Promise.all(options.topicIds.map(id => dbGet('topics', id)))
    : await dbGetAll('topics');

  const validTopics = topics.filter(Boolean);

  // Gather summaries for selected topics
  const allSummaries = [];
  for (const topic of validTopics) {
    for (const sid of (topic.summaryIds || [])) {
      const s = await dbGet('summaries', sid);
      if (s) allSummaries.push({ ...s, topicName: topic.name });
    }
  }

  // Optionally gather raw conversations
  let rawConvs = [];
  if (options.includeRaw) {
    const convIds = new Set(allSummaries.map(s => s.conversationId));
    for (const id of convIds) {
      const c = await dbGet('conversations', id);
      if (c) rawConvs.push(c);
    }
  }

  switch (target) {
    case 'claude': return exportForClaude(validTopics, allSummaries, rawConvs, options);
    case 'chatgpt': return exportForChatGPT(validTopics, allSummaries, rawConvs, options);
    case 'gemini': return exportForGemini(validTopics, allSummaries, rawConvs, options);
    case 'markdown': return exportAsMarkdown(validTopics, allSummaries, rawConvs, options);
    case 'json': return exportAsJSON(validTopics, allSummaries, rawConvs, options);
    default: return exportAsMarkdown(validTopics, allSummaries, rawConvs, options);
  }
}

function exportForClaude(topics, summaries, rawConvs, options) {
  let md = `# Project Knowledge Base\n\n`;
  md += `<context>\nThis knowledge base was compiled from AI conversations across multiple platforms.\n`;
  md += `Generated by AI Context Bridge on ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}.\n`;
  md += `Topics: ${topics.length} | Summaries: ${summaries.length}\n</context>\n\n`;

  for (const topic of topics) {
    const topicSummaries = summaries.filter(s => s.topicName === topic.name);
    if (topicSummaries.length === 0) continue;

    md += `## ${topic.name}\n\n`;

    // Key decisions across all summaries in this topic
    if (options.includeDecisions !== false) {
      const decisions = topicSummaries.flatMap(s => s.decisions || []).filter(Boolean);
      if (decisions.length > 0) {
        md += `### Key Decisions\n`;
        decisions.forEach(d => { md += `- ${d}\n`; });
        md += '\n';
      }
    }

    // Insights
    if (options.includeInsights !== false) {
      const insights = topicSummaries.flatMap(s => s.keyInsights || []).filter(Boolean);
      if (insights.length > 0) {
        md += `### Key Insights\n`;
        insights.forEach(i => { md += `- ${i}\n`; });
        md += '\n';
      }
    }

    // Summaries
    for (const s of topicSummaries) {
      md += `### ${s.title}\n`;
      md += `${s.summary}\n\n`;
    }

    // Code
    if (options.includeCode !== false) {
      const code = topicSummaries.flatMap(s => s.codeSnippets || []).filter(Boolean);
      if (code.length > 0) {
        md += `### Code Reference\n`;
        code.forEach(c => {
          if (c.description) md += `**${c.description}**\n`;
          md += `\`\`\`${c.language || ''}\n${c.code}\n\`\`\`\n\n`;
        });
      }
    }

    md += '---\n\n';
  }

  if (options.includeRaw && rawConvs.length > 0) {
    md += `## Raw Conversations\n\n`;
    for (const conv of rawConvs) {
      md += `### ${conv.title}\n`;
      conv.messages.forEach(m => {
        md += `**${m.role === 'user' ? 'User' : 'Assistant'}:**\n${m.content}\n\n`;
      });
      md += '---\n\n';
    }
  }

  return md;
}

function exportForChatGPT(topics, summaries, rawConvs, options) {
  let md = `# Knowledge Base\n`;
  md += `Generated by AI Context Bridge\n\n`;

  for (const topic of topics) {
    const topicSummaries = summaries.filter(s => s.topicName === topic.name);
    if (topicSummaries.length === 0) continue;

    md += `## ${topic.name}\n\n`;

    for (const s of topicSummaries) {
      md += `### ${s.title}\n`;
      if (options.includeInsights !== false && s.keyInsights?.length) {
        md += `**Key Insights:**\n`;
        s.keyInsights.forEach(i => { md += `- ${i}\n`; });
        md += '\n';
      }
      if (options.includeDecisions !== false && s.decisions?.length) {
        md += `**Decisions:**\n`;
        s.decisions.forEach(d => { md += `- ${d}\n`; });
        md += '\n';
      }
      md += `${s.summary}\n\n`;

      if (options.includeCode !== false && s.codeSnippets?.length) {
        s.codeSnippets.forEach(c => {
          if (c.description) md += `**${c.description}**\n`;
          md += `\`\`\`${c.language || ''}\n${c.code}\n\`\`\`\n\n`;
        });
      }
    }

    md += '---\n\n';
  }

  return md;
}

function exportForGemini(topics, summaries, rawConvs, options) {
  // Gemini handles clean markdown well
  return exportForChatGPT(topics, summaries, rawConvs, options);
}

function exportAsMarkdown(topics, summaries, rawConvs, options) {
  let md = `# AI Context Bridge - Knowledge Export\n`;
  md += `Exported: ${new Date().toISOString()}\n\n`;

  for (const topic of topics) {
    const topicSummaries = summaries.filter(s => s.topicName === topic.name);
    if (topicSummaries.length === 0) continue;

    md += `## ${topic.name}\n`;
    md += `Tags: ${topic.tags.join(', ')}\n\n`;

    for (const s of topicSummaries) {
      md += `### ${s.title}\n`;
      md += `${s.summary}\n\n`;

      if (options.includeInsights !== false && s.keyInsights?.length) {
        md += `**Insights:**\n`;
        s.keyInsights.forEach(i => { md += `- ${i}\n`; });
        md += '\n';
      }
      if (options.includeDecisions !== false && s.decisions?.length) {
        md += `**Decisions:**\n`;
        s.decisions.forEach(d => { md += `- ${d}\n`; });
        md += '\n';
      }
      if (options.includeCode !== false && s.codeSnippets?.length) {
        s.codeSnippets.forEach(c => {
          md += `\`\`\`${c.language || ''}\n${c.code}\n\`\`\`\n\n`;
        });
      }
    }

    md += '---\n\n';
  }

  return md;
}

function exportAsJSON(topics, summaries, rawConvs, options) {
  return JSON.stringify({
    version: '1.0',
    exportedAt: new Date().toISOString(),
    topics,
    summaries,
    conversations: options.includeRaw ? rawConvs : []
  }, null, 2);
}
